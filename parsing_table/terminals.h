#ifndef TERMINALS_H
#define TERMINALS_H

#include <string>
#include <unordered_map>
#include <unordered_set>
#include <stdexcept>
#include "nonterminals.h"


enum Terminal {
    T_CONST,
    T_IFJ,
    T_EQUAL,
    T_AT_IMPORT,
    T_LEFT_PARENTHESIS,
    T_RIGHT_PARENTHESIS,
    T_SEMICOLON,
    T_PUB,
    T_FN,
    T_ID,
    T_COLON,
    T_COMMA,
    T_VOID,
    T_INT,
    T_INT_OR_NULL,
    T_FLOAT,
    T_FLOAT_OR_NULL,
    T_STRING,
    T_STRING_OR_NULL,
    T_VAR,
    T_IF,
    T_ELSE,
    T_PIPE,
    T_LEFT_CURLY_BRACKET,
    T_RIGHT_CURLY_BRACKET,
    T_WHILE,
    T_RETURN,
    T_DOUBLE_EQUAL,
    T_NOT_EQUAL,
    T_LESS_THAN,
    T_GREATER_THAN,
    T_LESS_THAN_OR_EQUAL,
    T_GREATER_THAN_OR_EQUAL,
    T_PLUS,
    T_MINUS,
    T_MULTIPLY,
    T_DIVIDE,
    T_DOT,
    T_INT_LITERAL,
    T_FLOAT_LITERAL,
    T_STRING_LITERAL,
    T_NULL_LITERAL,
    T_EOF,
    T_EPSILON,
    TERMINAL_COUNT,  // Number of terminals
};

std::unordered_map<std::string, Terminal> terminalMap = {
    {"IMPORT", T_AT_IMPORT},
    {"IFJ", T_IFJ},
    {"PUB", T_PUB},
    {"FN", T_FN},
    {"CONST", T_CONST},
    {"ASSIGNMENT", T_EQUAL},
    {"LEFT_BRACKET", T_LEFT_PARENTHESIS},
    {"RIGHT_BRACKET", T_RIGHT_PARENTHESIS},
    {"SEMICOLON", T_SEMICOLON},
    {"ID", T_ID},
    {"COLON", T_COLON},
    {"COMMA", T_COMMA},
    {"VOID", T_VOID},
    {"INT", T_INT},
    {"INT_OR_NULL", T_INT_OR_NULL},
    {"FLOAT", T_FLOAT},
    {"FLOAT_OR_NULL", T_FLOAT_OR_NULL},
    {"STRING", T_STRING},
    {"STRING_OR_NULL", T_STRING_OR_NULL},
    {"VAR", T_VAR},
    {"IF", T_IF},
    {"ELSE", T_ELSE},
    {"PIPE", T_PIPE},
    {"LEFT_CURLY_BRACKET", T_LEFT_CURLY_BRACKET},
    {"RIGHT_CURLY_BRACKET", T_RIGHT_CURLY_BRACKET},
    {"WHILE", T_WHILE},
    {"RETURN", T_RETURN},
    {"IDENTITY", T_DOUBLE_EQUAL},
    {"NOT_EQUAL", T_NOT_EQUAL},
    {"LESS_THAN", T_LESS_THAN},
    {"GREATER_THAN", T_GREATER_THAN},
    {"LESS_THAN_OR_EQUAL", T_LESS_THAN_OR_EQUAL},
    {"GREATER_THAN_OR_EQUAL", T_GREATER_THAN_OR_EQUAL},
    {"PLUS", T_PLUS},
    {"MINUS", T_MINUS},
    {"MULTIPLICATION", T_MULTIPLY},
    {"DIVISION", T_DIVIDE},
    {"DOT", T_DOT},
    {"INT_LITERAL", T_INT_LITERAL},
    {"FLOAT_LITERAL", T_FLOAT_LITERAL},
    {"STRING_LITERAL", T_STRING_LITERAL},
    {"NULL_LITERAL", T_NULL_LITERAL},
    {"EOF", T_EOF},
    {"EPSILON", T_EPSILON},
};

std::array<std::string, TERMINAL_COUNT> invTerminalMap = {
    "T_HASH_CONST",
    "T_HASH_IFJ",
    "T_HASH_ASSIGNMENT",
    "T_HASH_IMPORT",
    "T_HASH_LEFT_BRACKET",
    "T_HASH_RIGHT_BRACKET",
    "T_HASH_SEMICOLON",
    "T_HASH_PUB",
    "T_HASH_FN",
    "T_HASH_ID",
    "T_HASH_COLON",
    "T_HASH_COMMA",
    "T_HASH_VOID",
    "T_HASH_INT",
    "T_HASH_INT_OR_NULL",
    "T_HASH_FLOAT",
    "T_HASH_FLOAT_OR_NULL",
    "T_HASH_STRING",
    "T_HASH_STRING_OR_NULL",
    "T_HASH_VAR",
    "T_HASH_IF",
    "T_HASH_ELSE",
    "T_HASH_PIPE",
    "T_HASH_LEFT_CURLY_BRACKET",
    "T_HASH_RIGHT_CURLY_BRACKET",
    "T_HASH_WHILE",
    "T_HASH_RETURN",
    "T_HASH_IDENTITY",
    "T_HASH_NOT_EQUAL",
    "T_HASH_LESS_THAN",
    "T_HASH_GREATER_THAN",
    "T_HASH_LESS_THAN_OR_EQUAL",
    "T_HASH_GREATER_THAN_OR_EQUAL",
    "T_HASH_PLUS",
    "T_HASH_MINUS",
    "T_HASH_MULTIPLICATION",
    "T_HASH_DIVISION",
    "T_HASH_DOT",
    "T_HASH_INT_LITERAL",
    "T_HASH_FLOAT_LITERAL",
    "T_HASH_STRING_LITERAL",
    "T_HASH_NULL_LITERAL",
    "T_HASH_EOF",
    "T_HASH_EPSILON",
};

Terminal getTerminal(const std::string& token) {
    // Ensure the token exists in the map to avoid exceptions
    auto it = terminalMap.find(token);
    if (it != terminalMap.end()) {
        return it->second;
    }
    throw std::invalid_argument("Invalid token"); // Handle the case where the token is not found
}

#endif // TERMINALS_H
